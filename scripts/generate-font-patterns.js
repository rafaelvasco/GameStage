#!/usr/bin/env node

/**
 * Build-time script to convert binary font patterns to optimized hexadecimal format
 * This script reads DefaultFontPatterns.ts and generates DefaultFontPatternsGenerated.ts
 */

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Paths
const srcDir = path.join(__dirname, "../src/content/builtin");
const inputFile = path.join(srcDir, "DefaultFontPatterns.ts");
const outputFile = path.join(srcDir, "DefaultFontPatternsGenerated.ts");

/**
 * Convert binary string to hexadecimal
 */
function binaryToHex(binaryString) {
  const decimal = parseInt(binaryString, 2);
  return "0x" + decimal.toString(16).toUpperCase().padStart(2, "0");
}

/**
 * Process character patterns and convert to hex
 */
async function processPatterns() {
  console.log("Reading binary patterns from:", inputFile);

  // Read and parse the input file
  const content = fs.readFileSync(inputFile, "utf8");

  // Extract the CHARACTER_PATTERNS object using regex
  const patternsMatch = content.match(
    /export const CHARACTER_PATTERNS = \{([\s\S]*?)\};/
  );
  if (!patternsMatch) {
    throw new Error("Could not find CHARACTER_PATTERNS in input file");
  }

  // Parse the patterns manually to avoid eval
  const patternsObject = {};
  const patternsText = patternsMatch[1];

  // Split by character definitions - handle both quoted and unquoted keys
  const charMatches = patternsText.match(
    /(["'`])(.*?)\1:\s*\[([\s\S]*?)\]|([A-Za-z_$][A-Za-z0-9_$]*):\s*\[([\s\S]*?)\]/g
  );
  if (!charMatches) {
    throw new Error("Could not parse character patterns");
  }

  for (const charMatch of charMatches) {
    let char, arrayContent;

    // Try quoted key first
    let charDefMatch = charMatch.match(/(["'`])(.*?)\1:\s*\[([\s\S]*?)\]/);
    if (charDefMatch) {
      char = charDefMatch[2];
      arrayContent = charDefMatch[3];
    } else {
      // Try unquoted key (like A, B, C)
      charDefMatch = charMatch.match(
        /([A-Za-z_$][A-Za-z0-9_$]*):\s*\[([\s\S]*?)\]/
      );
      if (charDefMatch) {
        char = charDefMatch[1];
        arrayContent = charDefMatch[2];
      } else {
        continue;
      }
    }

    // Extract binary strings from the array
    const binaryStrings = [];
    const stringMatches = arrayContent.match(/"([01]{8})"/g);
    if (stringMatches) {
      for (const stringMatch of stringMatches) {
        binaryStrings.push(stringMatch.replace(/"/g, ""));
      }
    }

    if (binaryStrings.length === 8) {
      patternsObject[char] = binaryStrings;
    }
  }

  const hexPatterns = {};
  let totalPatterns = 0;
  let totalBytes = 0;

  console.log("Converting patterns to hexadecimal...");

  for (const [char, binaryStrings] of Object.entries(patternsObject)) {
    const hexValues = binaryStrings.map((binaryString) => {
      totalBytes++;
      return binaryToHex(binaryString);
    });

    hexPatterns[char] = hexValues;
    totalPatterns++;
  }

  console.log(
    `Converted ${totalPatterns} character patterns (${totalBytes} bytes total)`
  );

  return hexPatterns;
}

/**
 * Generate the output TypeScript file
 */
function generateOutput(hexPatterns) {
  const timestamp = new Date().toISOString();

  let output = `/**
 * Auto-generated optimized font patterns
 * Generated on: ${timestamp}
 * 
 * This file contains hexadecimal representations of 8x8 bitmap font patterns
 * for faster runtime performance. Each pattern is an array of 8 hex values
 * representing the 8 rows of the character bitmap.
 * 
 * DO NOT EDIT THIS FILE MANUALLY - it will be overwritten by the build script
 */

export const CHARACTER_PATTERNS_HEX: { [key: string]: number[] } = {
`;

  // Sort patterns by character code for consistent output
  const sortedChars = Object.keys(hexPatterns).sort((a, b) => {
    return a.charCodeAt(0) - b.charCodeAt(0);
  });

  for (let i = 0; i < sortedChars.length; i++) {
    const char = sortedChars[i];
    const hexValues = hexPatterns[char];
    const charCode = char.charCodeAt(0);

    // Escape special characters for the key
    let keyString;
    if (char === '"') {
      keyString = `'"'`;
    } else if (char === "'") {
      keyString = `"'"`;
    } else if (char === "\\") {
      keyString = `"\\\\"`;
    } else {
      keyString = `"${char}"`;
    }

    output += `  ${keyString}: [${hexValues.join(", ")}], // ${
      char === " " ? "Space" : char
    } (${charCode})`;

    if (i < sortedChars.length - 1) {
      output += "\n";
    }
  }

  output += "\n};\n";

  // Add conversion function for runtime use
  output += `
/**
 * Convert character code to pattern array
 * Returns the hex pattern for the given character code, or undefined if not found
 */
export function getCharacterPattern(charCode: number): number[] | undefined {
  const char = String.fromCharCode(charCode);
  return CHARACTER_PATTERNS_HEX[char];
}

/**
 * Check if a character has a pattern defined
 */
export function hasCharacterPattern(charCode: number): boolean {
  const char = String.fromCharCode(charCode);
  return char in CHARACTER_PATTERNS_HEX;
}

/**
 * Get all supported character codes
 */
export function getSupportedCharCodes(): number[] {
  return Object.keys(CHARACTER_PATTERNS_HEX).map(char => char.charCodeAt(0)).sort((a, b) => a - b);
}
`;

  return output;
}

/**
 * Main execution
 */
async function main() {
  try {
    console.log("Starting font pattern optimization...");

    // Check if input file exists
    if (!fs.existsSync(inputFile)) {
      throw new Error(`Input file not found: ${inputFile}`);
    }

    // Process patterns
    const hexPatterns = await processPatterns();

    // Generate output
    const output = generateOutput(hexPatterns);

    // Write output file
    console.log("Writing optimized patterns to:", outputFile);
    fs.writeFileSync(outputFile, output, "utf8");

    // Calculate file size reduction
    const inputSize = fs.statSync(inputFile).size;
    const outputSize = fs.statSync(outputFile).size;
    const reduction = (((inputSize - outputSize) / inputSize) * 100).toFixed(1);

    console.log(`\nOptimization complete!`);
    console.log(`Input size:  ${inputSize} bytes`);
    console.log(`Output size: ${outputSize} bytes`);
    console.log(
      `Reduction:   ${reduction}% (${inputSize - outputSize} bytes saved)`
    );
    console.log(
      `\nGenerated file: ${path.relative(process.cwd(), outputFile)}`
    );
  } catch (error) {
    console.error("Error:", error.message);
    process.exit(1);
  }
}

main();
